package com.github.rogerhowell.javaparser_ast_inspector.plugin.ui.swing_components.forms;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ParserConfiguration;
import com.github.javaparser.Problem;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.comments.Comment;
import com.github.javaparser.ast.expr.LiteralExpr;
import com.github.javaparser.ast.expr.Name;
import com.github.javaparser.ast.expr.SimpleName;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.printers.ASCIITreePrinter;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.services.HighlightingService;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.services.PrinterService;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.ui.swing_components.NodeDetailsTextPane;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.ui.swing_components.config_panel.ConfigPanel;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.ui.swing_components.output_results_tabs.ParseResultsTabPanesContainer;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.util.Constants;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.util.NotificationLogger;
import com.github.rogerhowell.javaparser_ast_inspector.plugin.util.PsiUtil;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.IconLoader;
import com.intellij.openapi.wm.ToolWindow;
import com.intellij.psi.PsiFile;
import com.intellij.ui.JBColor;
import com.intellij.ui.TreeSpeedSearch;
import com.intellij.ui.treeStructure.Tree;
import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Path;
import java.util.List;
import java.util.Optional;

public class AstInspectorToolWindow implements Form {

    private static final NotificationLogger notificationLogger = new NotificationLogger(AstInspectorToolWindow.class);

    @NotNull
    private final Project project;

    @NotNull
    private final ToolWindow toolWindow;

    // Form Elements
    private JPanel mainPanel;

    private ConfigPanel configPanel;

    // Buttons
    private JButton gitHubButton;
    private JButton javaParserButton;
    private JButton resetButton;
    private JButton parseButton;

    private JTree                         tree1;
    private NodeDetailsTextPane           nodeDetailsTextPane;
    private JTabbedPane                   tabbedPane;
    private ParseResultsTabPanesContainer parseResultsTabPanesContainer1;


    public AstInspectorToolWindow(@NotNull final Project project, @NotNull final ToolWindow toolWindow) {
        this.project = project;
        this.toolWindow = toolWindow;
    }


    private static void browseToUrl(@NotNull final String url) {
        notificationLogger.info("BUTTON CLICK: URL=" + url);
        try {
            Desktop.getDesktop().browse(URI.create(url));
        } catch (IOException ioException) {
            ioException.printStackTrace();
            notificationLogger.warn(ioException.getMessage(), ioException);
        }
    }


    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        createUIComponents();
        mainPanel = new JPanel();
        mainPanel.setLayout(new GridLayoutManager(1, 4, new Insets(0, 0, 0, 0), -1, -1, false, true));
        final JPanel panel1 = new JPanel();
        panel1.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));
        mainPanel.add(panel1, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        tabbedPane = new JTabbedPane();
        panel1.add(tabbedPane, new GridConstraints(0, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, new Dimension(200, 200), null, 0, false));
        final JPanel panel2 = new JPanel();
        panel2.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane.addTab("Untitled", panel2);
        final JTabbedPane tabbedPane1 = new JTabbedPane();
        tabbedPane1.setTabPlacement(2);
        panel2.add(tabbedPane1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, new Dimension(200, 200), null, 0, false));
        final JPanel panel3 = new JPanel();
        panel3.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane1.addTab("Inspect", panel3);
        final JSplitPane splitPane1 = new JSplitPane();
        splitPane1.setDividerLocation(300);
        splitPane1.setOneTouchExpandable(false);
        panel3.add(splitPane1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, new Dimension(200, 200), null, 1, false));
        final JScrollPane scrollPane1 = new JScrollPane();
        splitPane1.setLeftComponent(scrollPane1);
        tree1.setShowsRootHandles(true);
        scrollPane1.setViewportView(tree1);
        final JScrollPane scrollPane2 = new JScrollPane();
        splitPane1.setRightComponent(scrollPane2);
        scrollPane2.setViewportView(nodeDetailsTextPane);
        final JPanel panel4 = new JPanel();
        panel4.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane1.addTab("Export", panel4);
        final JPanel panel5 = new JPanel();
        panel5.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane1.addTab("Log", panel5);
        final JPanel panel6 = new JPanel();
        panel6.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane1.addTab("Parse Results", panel6);
        final JPanel panel7 = new JPanel();
        panel7.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane1.addTab("Tokens", panel7);
        final JSeparator separator1 = new JSeparator();
        separator1.setOrientation(1);
        mainPanel.add(separator1, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_VERTICAL, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        final JPanel panel8 = new JPanel();
        panel8.setLayout(new GridLayoutManager(2, 1, new Insets(10, 5, 5, 2), -1, -1));
        mainPanel.add(panel8, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, 1, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 1, false));
        final JScrollPane scrollPane3 = new JScrollPane();
        panel8.add(scrollPane3, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, 1, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        scrollPane3.setViewportView(configPanel);
        final JPanel panel9 = new JPanel();
        panel9.setLayout(new GridLayoutManager(2, 2, new Insets(5, 5, 5, 5), -1, -1, true, true));
        panel8.add(panel9, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        parseButton.setText("Parse");
        panel9.add(parseButton, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        resetButton.setText("Reset");
        panel9.add(resetButton, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        gitHubButton.setText("Visit GitHub");
        panel9.add(gitHubButton, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        javaParserButton.setText("JavaParser.org");
        panel9.add(javaParserButton, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JPanel panel10 = new JPanel();
        panel10.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        mainPanel.add(panel10, new GridConstraints(0, 3, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        panel10.add(parseResultsTabPanesContainer1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        final JPanel panel11 = new JPanel();
        panel11.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        parseResultsTabPanesContainer1.addTab("Untitled", panel11);
    }


    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() { return mainPanel; }


    private void astDisplaySelectionListener(TreeSelectionEvent e) {
        notificationLogger.traceEnter(this.project);

        DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) this.tree1.getLastSelectedPathComponent();
        if (selectedNode != null) {
            final Object node  = selectedNode.getUserObject();
            final TNode  tNode = (TNode) node;

            // Update "selected" label
//            this.label_selected.setText("Selected: [" + tNode.toString() + "]");

            // Update the side panel
            this.updateSidebar(selectedNode);

            // Update the shared service/record of the currently selected node
            // TODO: Observer pattern and notify watchers?
            HighlightingService.getInstance().setSelectedNode(tNode.getNode());

            FileEditorManager manager = FileEditorManager.getInstance(this.project);
            final Editor      editor  = manager.getSelectedTextEditor();

            PsiUtil.getCurrentFileInEditor(this.project).ifPresent(psiFile -> {
                HighlightingService.getInstance().updateHighlight(psiFile, editor);
            });
        }
    }


    private DefaultMutableTreeNode buildTreeNodes(DefaultMutableTreeNode parent, Node node) {
        notificationLogger.traceEnter(this.project);

        // Setup tree node for the given node
        DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode(new TNode(node));

        // Add this tree node to its parent, if given
        if (parent != null) {
            parent.add(treeNode);
        }

        // Recursively add children
        List<Node> children = node.getChildNodes();
        children.forEach(childNode -> {
            treeNode.add(this.buildTreeNodes(treeNode, childNode));
        });

        return treeNode;
    }


    private JButton buttonWithIcon(@NotNull final String resourcePath) {
        final JButton jButton = new JButton();

        final Icon icon = IconLoader.getIcon(resourcePath);
        jButton.setIcon(icon);

        return jButton;
    }


    private void createUIComponents() {
        notificationLogger.traceEnter(this.project);

        //
        this.initButtons();

        //
        this.configPanel = new ConfigPanel(new ParserConfiguration());

        //
        this.tree1 = this.setupTree();
        this.nodeDetailsTextPane = new NodeDetailsTextPane();

        this.parseResultsTabPanesContainer1 = new ParseResultsTabPanesContainer();

        this.doReset();
    }


    public Optional<CompilationUnit> doParse() {
        notificationLogger.traceEnter(this.project);

        final Optional<PsiFile> currentFileInEditor = PsiUtil.getCurrentFileInEditor(this.project);
        if (currentFileInEditor.isPresent()) {
            final PsiFile    psiFile    = currentFileInEditor.get();
            final JavaParser javaParser = new JavaParser(this.configPanel.getConfigFromForm());

            this.tabbedPane.setTitleAt(0, psiFile.getName());

            // parse result
//            final Optional<ParseResult<CompilationUnit>> optionalParseResult = parsePsiFile_editorContents(psiFile);
            final Optional<ParseResult<CompilationUnit>> optionalParseResult = this.parsePsiFile_diskContents(javaParser, psiFile);

            if (optionalParseResult.isPresent()) {
                final ParseResult<CompilationUnit> parseResult = optionalParseResult.get();

                // FIXME
                this.parseResultsTabPanesContainer1.addParseResultPane(this.project, psiFile, parseResult);

                return this.handleParseResult(psiFile, parseResult);
            } else {
                notificationLogger.warn(this.project, "No parse result available for file: " + psiFile);
            }
        } else {
            notificationLogger.warn(this.project, "No file selected in editor.");
        }

        return Optional.empty();
    }


    public void doReset() {
        notificationLogger.traceEnter(this.project);

        this.updateTree(null);

//        this.setParseResultTextPane("Reset");
//        this.setParseResult(""); // The parse result is the output textbox

        // Reset the sidebar content, ready to be inserted into again:
        this.nodeDetailsTextPane.clear();
        this.nodeDetailsTextPane.appendLine("No node selected");

        //
        if (this.tabbedPane != null && this.tabbedPane.getTabCount() > 0) {
            this.tabbedPane.setTitleAt(0, "No file parsed.");
        } else {
            notificationLogger.debug(this.project, "Tabbed pane either null or empty: " + this.tabbedPane);
        }
    }


    @Override
    public Optional<JPanel> getMainPanel() {
        return Optional.ofNullable(this.mainPanel);
    }


    private Optional<CompilationUnit> handleParseResult(final PsiFile psiFile, ParseResult<CompilationUnit> parseResult) {
        notificationLogger.traceEnter(this.project);

        // Parse result not present or not successful
        if (!parseResult.isSuccessful()) {
            notificationLogger.warn(this.project, "Parsing has been unsuccessful.");
        }
        if (!parseResult.getProblems().isEmpty()) {
            StringBuilder       message  = new StringBuilder("Found " + parseResult.getProblems().size() + " problems found when parsing: ");
            final List<Problem> problems = parseResult.getProblems();
            for (int i = 0; i < problems.size(); i++) {
                final Problem problem = problems.get(i);
                message.append("\n")
                       .append("\t").append("Problem #").append(i).append(": ").append(problem.getMessage());
            }
            notificationLogger.warn(this.project, message.toString());
        }
        if (!parseResult.getResult().isPresent()) {
            notificationLogger.error(this.project, "Parse result null or not present.");
            notificationLogger.info(this.project, "parseResult.getResult() = " + parseResult.getResult());
            return Optional.empty();
        }

        notificationLogger.debug(this.project, "Parse result: " + parseResult.toString());
        return parseResult.getResult();
    }


    private void initButtons() {
        notificationLogger.traceEnter(this.project);

        // Create buttons
        this.parseButton = new JButton();
        this.resetButton = new JButton();
        this.gitHubButton = new JButton();
        this.javaParserButton = this.buttonWithIcon("/logos/jp-logo_13x13.png");

        // Add button click handlers
        this.parseButton.addActionListener(e -> this.parseButtonClickHandler());
        this.resetButton.addActionListener(e -> this.resetButtonClickHandler());
        this.gitHubButton.addActionListener(e -> browseToUrl(Constants.URL_GITHUB_PLUGIN));
        this.javaParserButton.addActionListener(e -> browseToUrl(Constants.URL_WEBSITE_JP));

    }


    private void parseButtonClickHandler() {
        notificationLogger.traceEnter(this.project);

        final Optional<CompilationUnit> optionalCu = this.doParse();
        if (optionalCu.isPresent()) {
            CompilationUnit compilationUnit = optionalCu.get();

            String  outputFormat    = this.configPanel.getSelectedExportType();
            boolean includeNodeType = this.configPanel.getOutputNodeType();

            this.updateExport(outputFormat, compilationUnit);
            this.updateTree(compilationUnit);
        } else {
            notificationLogger.warn(this.project, "Compilation Unit not found.");
        }
    }


    private Optional<ParseResult<CompilationUnit>> parsePsiFile_diskContents(JavaParser javaParser, PsiFile psiFile) {
        notificationLogger.traceEnter(this.project);
        try {
            final Path                         path   = PsiUtil.pathForPsi(psiFile);
            final ParseResult<CompilationUnit> result = javaParser.parse(path);
            return Optional.of(result);
        } catch (IOException e) {
            notificationLogger.warn(this.project, "Error trying to parse file.", e);
            e.printStackTrace();
            return Optional.empty();
        }
    }


    private void resetButtonClickHandler() {
        notificationLogger.traceEnter(this.project);
        this.doReset();
    }


    private Tree setupTree() {
        notificationLogger.traceEnter(this.project);

        final Tree tree = new Tree();
        new TreeSpeedSearch(tree); // Note: Just calling the constructor is enough to enable speed search.

        // Custom renderer -- e.g. to set colours on the nodes
        tree.setCellRenderer(new MyTreeCellRenderer());

        // Click handler for selection of AST nodes
        tree.getSelectionModel().addTreeSelectionListener(this::astDisplaySelectionListener);

        // Add click handler
        tree.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                int      selRow  = AstInspectorToolWindow.this.tree1.getRowForLocation(e.getX(), e.getY());
                TreePath selPath = AstInspectorToolWindow.this.tree1.getPathForLocation(e.getX(), e.getY());
                if (selRow != -1) {
                    if (e.getClickCount() == 1) {
                        notificationLogger.debug(AstInspectorToolWindow.this.project, String.format("SINGLE CLICK:: selRow: %d ;; selPath: %s", selRow, selPath));
//                        mySingleClick(selRow, selPath);
                    } else if (e.getClickCount() == 2) {
                        notificationLogger.debug(AstInspectorToolWindow.this.project, String.format("DOUBLE CLICK:: selRow: %d ;; selPath: %s", selRow, selPath));
//                        myDoubleClick(selRow, selPath);
                    }
                }
            }
        });

        return tree;
    }


    private void updateExport(String outputFormat, CompilationUnit compilationUnit) {
        notificationLogger.traceEnter(this.project);

        // Do exporting stuff
        notificationLogger.info(this.project, "Exporting of the parsed file in various versions is temporarily unavailable.");
        String output = PrinterService.getInstance(this.project).outputAs(outputFormat, compilationUnit);

        // If custom dot image, do the image in addition to the textual dot string
        if ("Custom DOT Image".equals(outputFormat)) {
//            this.outputCustomDotImage(this.project.getBasePath());
            notificationLogger.info(this.project, "Custom DOT Image is temporarily unavailable.");
        }
    }


    private void updateSidebar(DefaultMutableTreeNode selectedTreeNode) {
        notificationLogger.traceEnter(this.project);

        final Object node         = selectedTreeNode.getUserObject();
        final TNode  tNode        = (TNode) node;
        final Node   selectedNode = tNode.getNode();

        // Log the selected node to the panel
        if (selectedNode == null) {
            // Reset the sidebar content, ready to be inserted into again:
            this.nodeDetailsTextPane.clear();
            this.nodeDetailsTextPane.appendLine("No node selected");
        } else {
            // Reset the sidebar content, ready to be inserted into again:
            this.nodeDetailsTextPane.clear();
            this.nodeDetailsTextPane.logNodeToTextPane(selectedNode);
        }

    }


    private void updateTree(CompilationUnit compilationUnit) {
        notificationLogger.traceEnter(this.project);

        if (compilationUnit == null) {
            final DefaultMutableTreeNode root = new DefaultMutableTreeNode("Not yet parsed.");
            this.tree1.setModel(new DefaultTreeModel(root, false));

        } else {
            final DefaultMutableTreeNode root = this.buildTreeNodes(null, compilationUnit);
            this.tree1.setModel(new DefaultTreeModel(root, false));
        }

        // Nudge the UI to update
        this.tree1.updateUI();
    }


    /**
     * A helper class used to model nodes within a UI tree displayed via a tool window/panel.
     */
    private static class TNode {
        private final Node node;


        /**
         * @param node The AST node that this UI tree node contains.
         */
        TNode(@NotNull Node node) {
            this.node = node;
        }


        /**
         * @return The AST node that this UI tree node contains.
         */
        public Node getNode() {
            return this.node;
        }


        /**
         * @return A string representation/summary of the AST node that this UI tree node contains.
         */
        public String toString() {
            return ASCIITreePrinter.CLASS_RANGE_SUMMARY_FORMAT.apply(this.node);
        }

    }

    public static class MyTreeCellRenderer extends DefaultTreeCellRenderer {

        private final Color COLOUR_COMMENT    = JBColor.GRAY.darker();
        private final Color COLOUR_IDENTIFIER = JBColor.BLUE.darker();
        private final Color COLOUR_LITERALS   = JBColor.GREEN.darker().darker();


        @Override
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean exp, boolean leaf, int row, boolean hasFocus) {
            super.getTreeCellRendererComponent(tree, value, sel, exp, leaf, row, hasFocus);

            Object userObject = ((DefaultMutableTreeNode) value).getUserObject();
            if (userObject instanceof String) {
                return this;
            } else if (userObject instanceof TNode) {
                final TNode tNode        = (TNode) userObject;
                final Node  selectedNode = tNode.getNode();
                this.setColourForNode(selectedNode);
                return this;
            } else {
                return this;
            }
        }


        private void setColourForNode(Node node) {
            if (node instanceof Name || node instanceof SimpleName) {
                // Formatting of names / identifiers
                this.setForeground(this.COLOUR_IDENTIFIER);
            } else if (node instanceof Comment) {
                // Formatting of comments
                this.setForeground(this.COLOUR_COMMENT);
            } else if (node instanceof LiteralExpr) {
                // Formatting of literals (e.g. strings, numbers)
                this.setForeground(this.COLOUR_LITERALS);
            } else {
                // Use defaults
            }
        }
    }

}
